package name.brian_gordon.securitydemo

import java.util.concurrent.atomic.AtomicInteger

import scala.concurrent.Promise

import org.joda.time.DateTime
import org.joda.time.Period
import org.joda.time.format.PeriodFormat
import org.joda.time.format.PeriodFormatterBuilder
import dispatch.Http
import grizzled.slf4j.Logging

/**
 * @author Brian Gordon
 */
object ExploitTaskRunner extends App with Logging {
    val startTime = DateTime.now()
    val numberOfWorkers = conf.getInt("number_of_workers");
    val resultPromise = Promise[String]()
    val attemptCounter = new AtomicInteger()
    val http = Http.configure(builder => {
        builder.setFollowRedirect(true)
        builder.setAcceptAnyCertificate(true)
    })

    // Start the workers.
    for (workerNum <- 1 to numberOfWorkers) {
        info(s"Starting worker $workerNum...")
        executor.execute(new ExploitTask(http, resultPromise, attemptCounter))
    }

    // Block until a worker returns the result.
    for (secret <- resultPromise.future) {
        val period = new Period(startTime, DateTime.now())
        info(s"Exploit successful after $attemptCounter attempts.")
        info(s"${period.toString(PeriodFormat.getDefault)} elapsed.")
        info(s"The secret is $secret.")
    }
}
